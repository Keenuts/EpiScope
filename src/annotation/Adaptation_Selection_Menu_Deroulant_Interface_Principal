#ce code affiche l'interface divisée, les 6 cases fictives avec le smeus deroulan et egalement les menus deroulant deroulant de la 
#partie gauche de meme taille que la partie droite.
#pour lancer ce code il faut avoir le fichier "Liste_Fruits.txt" dans le meme dossier qu ce fichier.
#il faut telechager de meme les codes "case_i.txt" (avec i=1 ..6) sur le drive dans programme>code26-11

import tkinter as tk
import customtkinter as ctk
import os



class Menu_symptomes(ctk.CTkFrame):
    def __init__(self, master, largeur_totale):
        super().__init__(master)
        Liste_cat = []
        self.options_symptomes = []
        self.liste_MenuDeroulant = []
        self.nb_menus = 0
        Liste_var_selected = []

        script_directory = os.path.dirname(os.path.abspath(__file__))
        Monfichier = os.path.join(script_directory, "Liste_Symptôme.txt")

        with open(Monfichier, 'r') as file:
            for line in file:
                line = line.strip()
                Liste = line.split(';')

                Liste_cat.append(Liste[0])

                var_selected = tk.StringVar()
                var_selected.set(Liste[0])
                Liste_var_selected.append(var_selected)

                Liste = Liste[1:]
                self.options_symptomes.append(Liste)
                self.nb_menus += 1

                MenuDeroulant = ctk.CTkOptionMenu(self, var_selected, values=Liste)
                self.liste_MenuDeroulant.append(MenuDeroulant)
                self.liste_MenuDeroulant[-1].grid(row=self.nb_menus, sticky="nsew", padx=5, pady=5)
                self.liste_MenuDeroulant[-1].set(Liste_cat[-1])

                # Ajuster la largeur des menus déroulants à 1/5 de la largeur totale
                menu_width = largeur_totale - 91
                self.liste_MenuDeroulant[-1].configure(width=int(menu_width), fg_color='Plum3')



                # Configuration de la fonction appelée lorsqu'une option est sélectionnée
                var_selected.trace_add('write', lambda *args, var=var_selected: Selection.on_select(var))

        self.entry = ctk.CTkEntry(self, placeholder_text="Symptomes")
        self.entry.grid(row=0)
        self.entry.bind("<KeyRelease>", self.filtrer_options)

    # definition des méthodes
    def filtrer_options(self, event): 
        """
        filtre les options d'un menu déroulant en fonction d'une recherche textuelle
        """
        recherche = self.entry.get().lower()
        for i in range(self.nb_menus) :
            options_filtrees = [option for option in self.options_symptomes[i] if recherche in option.lower()]
            self.liste_MenuDeroulant[i].configure(values=options_filtrees) 
    


class Selection(ctk.CTkFrame):
    def __init__(self, master=None):
        super().__init__(master)
        self.previous_selections = []
        # Création du Text (zone de texte en lecture seule)
        self.text_output = tk.Text(self, height=5, width=10, relief=tk.GROOVE, wrap=tk.WORD, state=tk.DISABLED)
        self.text_output.grid(row=5, column=5, pady=5)

    # Stocker la dernière valeur sélectionnée
    def on_select(self, *args, var=None):
        # Initialisation de la variable var
        if var is None:
            var = None

        if var:
            self.previous_selections.append(var)
            # Met à jour le contenu du Text avec les sélections précédentes et la sélection actuelle
            self.text_output.config(state=tk.NORMAL)  # Active la modification
            self.text_output.delete(1.0, tk.END)
            self.text_output.insert(tk.END, '\n'.join(self.previous_selections))
            self.text_output.config(state=tk.DISABLED)




class LecteurVideo:
    def __init__(self, fenetre):
        self.fenetre = fenetre
        self.fenetre.title("Lecteur Vidéo")
        self.cap = None
        self.video_paused = False


        # Cadres pour la partie de gauche, milieu et droite
        # Modify the frame initialization in the __init__ method of LecteurVideo class
        self.frame_left = ctk.CTkFrame(fenetre, fg_color='grey',border_width=5,border_color='Plum3' ,width=fenetre.winfo_screenwidth() // 5)
        self.frame_middle = ctk.CTkFrame(fenetre, fg_color='grey',border_width=5,border_color='Plum3' ,width=3 * (fenetre.winfo_screenwidth()) // 5, height=fenetre.winfo_screenheight() - 200 )  # Ajustement ici
        self.frame_right = ctk.CTkFrame(fenetre, fg_color='grey',border_width=5,border_color='Plum3' ,width=fenetre.winfo_screenwidth() // 5)


        # Placer les cadres dans la fenêtre
        self.frame_left.pack(side=ctk.LEFT, fill=ctk.Y)
        self.frame_middle.pack(side=ctk.LEFT, fill=ctk.BOTH, expand=True)
        self.frame_right.pack(side=ctk.RIGHT, fill=ctk.BOTH, expand=False)



        # Lire la vidéo avec OpenCV
        self.cap = None

        # Créer un Canvas pour afficher la vidéo
        self.canvas = ctk.CTkCanvas(self.frame_middle, bg='grey')
        self.canvas.pack(expand=True, fill=ctk.BOTH)

        # Binding du clic gauche à l'affichage du menu
        # self.canvas.bind("<Button-1>", self.afficher_menu_annotations)

        # Ajout de la partie gauche avec les menus déroulants
        self.menu_symptomes = Menu_symptomes(self.frame_left, self.frame_left.winfo_reqwidth())
        self.menu_symptomes.pack(side=ctk.LEFT, fill=ctk.Y)

        # Ajout de la partie droite avec les menus déroulants
        self.selection = Selection()
        self.selection.pack(side=ctk.RIGHT, fill=ctk.Y)

        # Barre de progression manuelle
        self.progress_slider =tk.Scale(self.frame_middle, from_=0, to=100, orient="horizontal", command=self.manual_update_progress)
        self.progress_slider.pack(side=tk.TOP, fill=tk.X)

        # Frame pour les boutons
        self.frame_CTkButton = ctk.CTkFrame(self.frame_middle, fg_color='grey', height=50)
        self.frame_CTkButton.pack(side=ctk.TOP, fill=ctk.BOTH)
     
        # Boutons
        self.bouton_reculer = ctk.CTkButton(self.frame_CTkButton, text="-2s", command=self.recule_progress,text_color='black',fg_color='Plum3')
        self.bouton_reculer.pack(side=ctk.LEFT, padx=50)

        self.bouton_pause_lecture = ctk.CTkButton(self.frame_CTkButton, text="Pause", command=self.pause_lecture,text_color='black',fg_color='Plum3')
        self.bouton_pause_lecture.pack(side=ctk.LEFT, padx=100)

        self.bouton_avancer = ctk.CTkButton(self.frame_CTkButton, text="+2s", command=self.avance_progress,text_color='black',fg_color='Plum3')
        self.bouton_avancer.pack(side=ctk.LEFT, padx=50)


        # Étiquettes pour afficher le temps écoulé et la durée totale
        self.label_temps = tk.Label(self.frame_middle, text="Temps écoulé: 0:00 / Durée totale: 0:00", bg='grey', fg='white')
        self.label_temps.pack(side=tk.BOTTOM, padx=20)

        self.fenetre.bind('<space>', lambda event: self.pause_lecture())
        self.fenetre.bind('<Right>', lambda event: self.avance_progress())
        self.fenetre.bind('<Left>', lambda event: self.recule_progress())

    
if __name__ == "__main__":
    root = ctk.CTk()
    root.geometry("{0}x{1}+0+0".format(root.winfo_screenwidth(), root.winfo_screenheight()))  # Plein écran
    lecteur = LecteurVideo(root)
    
    # Instanciation de la classe Selection avec le maître étant root
    selection = Selection(root)
    
    # Ajout de la partie droite avec les menus déroulants
    selection.pack(side=ctk.RIGHT, fill=ctk.Y)
    
    # Modification pour passer correctement la variable var_selected à on_select
    for var_selected in lecteur.menu_symptomes.Liste_var_selected:
        var_selected.trace_add('write', lambda *args, var=var_selected: selection.on_select(var=var.get()))
        # Notez le changement ici pour utiliser var au lieu de var.get()

    root.mainloop()




# class Menu_symptomes(ctk.CTkFrame):
#     def __init__(self, master, largeur_totale):
#         super().__init__(master)
#         Liste_cat = []
#         self.options_symptomes = []
#         self.liste_MenuDeroulant = []
#         self.nb_menus = 0
#         Liste_var_selected = []

#         script_directory = os.path.dirname(os.path.abspath(__file__))
#         Monfichier = os.path.join(script_directory, "Liste_Symptôme.txt")

#         with open(Monfichier, 'r') as file:
#             for line in file:
#                 line = line.strip()
#                 Liste = line.split(';')

#                 Liste_cat.append(Liste[0])

#                 var_selected = tk.StringVar()
#                 var_selected.set(Liste[0])
#                 Liste_var_selected.append(var_selected)

#                 Liste = Liste[1:]
#                 self.options_symptomes.append(Liste)
#                 self.nb_menus += 1

#                 MenuDeroulant = ctk.CTkOptionMenu(self, var_selected, values=Liste)
#                 self.liste_MenuDeroulant.append(MenuDeroulant)
#                 self.liste_MenuDeroulant[-1].grid(row=self.nb_menus, sticky="nsew", padx=5, pady=5)
#                 self.liste_MenuDeroulant[-1].set(Liste_cat[-1])

#                 # Ajuster la largeur des menus déroulants à 1/5 de la largeur totale
#                 menu_width = largeur_totale-91
#                 self.liste_MenuDeroulant[-1].configure(width=menu_width, fg_color='Plum3')

#                 # Configuration de la fonction appelée lorsqu'une option est sélectionnée
#                 var_selected.trace_add('write', lambda *args, var=var_selected: Selection.on_select(var))

#         self.entry = ctk.CTkEntry(self, placeholder_text="Symptomes")
#         self.entry.grid(row=0)
#         self.entry.bind("<KeyRelease>", self.filtrer_options)
    

# class Selection :
#     # Stocker la dernière valeur sélectionnée
#     def on_select(var_selected):
#         previous_selections = []
#         previous_selections.append(var_selected.get())

#         # Création du Text (zone de texte en lecture seule)
#         text_output = tk.Text(root, height=5, width=20, relief=tk.GROOVE, wrap=tk.WORD, state=tk.DISABLED)
#         text_output.grid(row=20, column=160, pady=10)
    
#         # Met à jour le contenu du Text avec les sélections précédentes et la sélection actuelle
#         text_output.config(state=tk.NORMAL)  # Active la modification
#         text_output.delete(1.0, tk.END)
#         text_output.insert(tk.END, '\n'.join(previous_selections))
#         text_output.config(state=tk.DISABLED)